alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
if [ "$PLATFORM" = "mingw" ] || [ "$PLATFORM" = "linux" ]; then alias ls='ls --color=auto'; fi
alias ll='ls -la'
alias la='ls -A'
alias l='ls -CF'
alias cls='clear && echo -e "\ec"'
alias rebash="[[ -f ~/.bashrc ]] && . ~/.bashrc || . ~/.bash_profile"
alias realias="unalias -a && rebash"
alias xx="exit"

# mc and cd trickery (mcd tries to match the param from the mc hotlist and then chdir there)
function mdcd () { mkdir -p "$@" && cd "$@"; }
alias md="mdcd"
alias mc=". /usr/lib/mc/mc-wrapper.sh"
alias cd..="cd .."
alias cd....="cd ../.."
MCD_PREV_DIR=~
MCD_SAVED_DIR=~
function mcd() {
  ESC=$(printf '\033')
  SHARE_FILE=/tmp/mcd-pwd
  MCD_SHARED_DIR=~
  if [ -f "${SHARE_FILE}" ]; then MCD_SHARED_DIR=$(cat /tmp/mcd-pwd); fi
  if [ "${1}" = '-' ]; then cd $MCD_PREV_DIR; return 0; fi
  if [ "${1}" = '--' ]; then cd $MCD_SAVED_DIR; return 0; fi
  if [ "${1}" = '---' ]; then cd $MCD_SHARED_DIR; return 0; fi
  if [ "${1}" = 'save' ]; then MCD_SAVED_DIR=$(pwd); return 0; fi
  if [ "${1}" = 'share' ]; then pwd > $SHARE_FILE; return 0; fi
  # you need to have an mc menu file
  FN=~/.config/mc/hotlist
  if [ ! -f "${FN}" ]; then echo -e "${RED}mc hotlist file missing${NOCOLOR}"; return 1; fi
  # help: list the mc directory hotlist
  if [ -z "${1}" ]; then
    grep ENTRY ${FN} | sed s'/\s*ENTRY "//' | sed "s/\" URL \"/ ${ESC}[1;30m=> /" | sed "s/\"$/${ESC}[0m/"
    echo -e "${DARKGRAY}saved: ${MCD_SAVED_DIR}\nshared: ${MCD_SHARED_DIR}\nprev: ${MCD_PREV_DIR}${NOCOLOR}" | sed "s/\/home\/$(whoami)/~/g"
    return 0
  fi
  # first try to grep it with `"X "` in the mc hotlist (useful for prefixed lists), then go for a looser grep
  TARGET=$(grep ENTRY ${FN} | grep "\"${1} " | head -1 | sed 's/.*URL "//' | sed 's/"$//')
  if [ $(echo $TARGET | wc -c) -gt 1 ]; then MCD_PREV_DIR=$(pwd); cd $TARGET; return 0; fi
  # since "X nnn" was not found (for example `2` with `1 foobar`), let's try "N xxx" (in the `foobar`)
  TARGET=$(grep ENTRY ${FN} | sed 's/\s*ENTRY "[0-9A-Z]*\s//' | grep "^${1}" | head -1 |sed 's/.*URL "//' | sed 's/"$//')
  if [ $(echo $TARGET | wc -c) -gt 1 ]; then MCD_PREV_DIR=$(pwd); cd $TARGET; return 0; fi
  cd $1
}
function _mcd() {
  local cur
  cur=${COMP_WORDS[COMP_CWORD]}
  FN=~/.config/mc/hotlist
  if [ ! -f "${FN}" ]; then return 1; fi
  WORDS=$(grep ENTRY ${FN} | sed 's/\s*ENTRY "[0-9A-Z]*\s//' | sed 's/[" ].*//' | tr '\n' ' ')
  COMPREPLY=($(compgen -W "save share ${WORDS}" -- ${cur}))
  return 0
}
complete -F _mcd mcd

# much short, very magic
alias g="git"
alias y="yarn"
if [ "$PLATFORM" = "mingw" ]; then alias y="node /c/Users/szabi/scoop/apps/yarn/current/Yarn/lib/cli.js"; fi
alias d="docker"
if [ "$PLATFORM" = "mingw" ]; then alias d='winpty docker'; fi
alias p='pm2'

# npm, nvm and yarn
alias nuke="rm -rf ./node_modules && npm cache clear --force && npm install --no-shrinkwrap --update-binary"
alias npmr='npm run'
alias npmrd='npm run dev'
alias npmt='npm test'
alias npmrt='npm test'
alias npmtw='npm run test:watch'
alias npmrtw='npm run test:watch'
alias npmrl='npm run lint'
alias npmi='npm install && cp package.json .package.json && git checkout package-lock.json'
alias yadd='y add -D'
alias yins='y install'
alias yrem='y remove'
alias ys='y start'
alias yc='y clean'
alias yex='y start:exposed'
alias nP='nvm-project'

# change to node version specified by project
function nvm-project() {
  if [ -f ".nvmrc" ]; then
    NVER=$(cat .nvmrc)
    echo -e "${GREEN}nvmrc found, using v${NVER}${NOCOLOR}"
    nvm install $NVER
  else
    # try to use the Dockerfile (for major node version), if we can't, then just use the fall back
    if [ -f "Dockerfile" ]; then
      NVER=$(cat Dockerfile | grep -o "FROM node:[0-9]\+" | sed "s/FROM node://" | head -n1)
      echo -e "${ORANGE}nvmrc NOT found, falling back to Dockerfile, using node v${NVER}${NOCOLOR}"
      nvm install $NVER
    else
      echo -e "${RED}nvmrc/Dockerfile NOT found, sorry${NOCOLOR}"
    fi
  fi
}

# print the current nvm node version in the prompt
function current_node() {
  # NVER=$(readlink ~/.nvm/current | grep -o "node\/v.*" | sed "s/node\/v//")
  if [[ $(command -v node | wc -l) -eq 1 ]]; then
    NVER=$(node -v)
    echo -e " ${CYAN}N:${NVER}${NOCOLOR}"
  fi
}

# editors and copy-paste (pri and sec)
alias nano='nano -x -w -z -H'
alias na='nano'
alias geany='geany'
if [ "$PLATFORM" = "macos" ]; then alias geany='open -a geany'; fi
if [ "$PLATFORM" = "mingw" ]; then alias geany='/c/Program\ Files\ \(x86\)/Geany/bin/geany.exe'; fi
alias vscode='code'
if [ "$PLATFORM" = "linux" ]; then
  alias pbcopy='xclip -i -sel p -f | xclip -i -sel c'
  alias pbpaste='xclip -selection clipboard -o'
fi
function copy-cat() { cat $@ | pbcopy; }
function copy-path() { readlink -f ${@:-.}; readlink -f ${@:-.} | head -c -1 | pbcopy; }
alias copy-fn='copy-path'

# edit popular files
alias ed-bp="${EDITOR} ~/.bash_profile"
alias ed-brc="${EDITOR} ~/.bashrc"
alias ed-ba="${EDITOR} ~/.bash_aliases"
alias ed-bs="${EDITOR} ~/.bash_secret"
alias ed-gc="${EDITOR} ~/.gitconfig"
alias ed-gi="${EDITOR} ~/.gitignore"
alias ed-mchot="${EDITOR} ~/.config/mc/hotlist"

# git prompt
function markup_git_branch() {
  if [[ -n $@ ]]; then
    if [[ -z $(git status --porcelain 2> /dev/null) ]]; then
      echo -e " ${GREEN}($@)${NOCOLOR}"
    else
      echo -e " ${RED}($@)${NOCOLOR}"
    fi
  fi
}
function parse_git_branch() {
  git branch --color=never 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \1/' | sed -e 's/feature/F/'
}

# detect mc subshell in prompt
function is_mc() {
  if [ -n "${MC_SID}" ]; then
    echo -e " ${ORANGE}MCâ–¾${NOCOLOR}"
  fi
}

# misc
function title() { echo -ne "\033]0;${1}\007"; }
alias t="title"
function titleprefix() { TITLEPREFIX="$1"; }
alias tp="titleprefix"
function jpg2mp4 () { ffmpeg -loop 1 -i "$1" -c:v libx264 -t 15 -pix_fmt yuv420p "$1.mp4"; }

# my file and mpd server, an ancient netbook
# for mingw use git sdk shell and `pacman -S expect`
function vacak_mpd() {
  NCMPCPP=1 expect -c '
    spawn ssh -o SendEnv=NCMPCPP szabi@$::env(VACAK_IP) -p1922
    log_user 0
    expect "assword:"; send "$::env(VACAK_PASSWORD)\r"
    interact
  '
}
function vacak_shell() {
  expect -c '
    spawn ssh szabi@$::env(VACAK_IP) -p1922
    log_user 0
    expect "assword:"; send "$::env(VACAK_PASSWORD)\r"
    interact
  '
}
