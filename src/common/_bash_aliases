alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
if [ "$PLATFORM" = "mingw" ] || [ "$PLATFORM" = "linux" ]; then alias ls='ls --color=auto'; fi
alias ll='ls -la'
alias la='ls -A'
alias l='ls -CF'
alias cls='clear && echo -e "\ec"'
alias rebash="[[ -f ~/.bashrc ]] && . ~/.bashrc || . ~/.bash_profile"
alias realias="unalias -a && rebash"
alias xx="exit"

# a slightly better rename - one argument will trigger readline for second
# (see also imv from renameutils or bash Ctrl-W Ctrl-Y Ctrl-Y for single words)
function mv() {
  if [ "$#" -eq 1 ] && [ -e "$1" ]; then
    read -ei "$1" newfilename; command mv -v "${1}" "${newfilename}"; return $?
  fi
  command mv "$@"; return $?
}

# mc and cd trickery (mcd tries to match the param from the mc hotlist and then chdir there)
# (adding "f" as the second param will just do an `&& fcd 1`, because lazyness)
function mdcd() { mkdir -p "$@" && cd "$@"; }
alias md="mdcd"
alias mc=". /usr/lib/mc/mc-wrapper.sh"
alias cd..="cd .."
alias cd....="cd ../.."
MCD_PREV_DIR=~
function mcd() {
  local AFTER="${2}"
  function __cd() { cd $1; if [ "${AFTER}" = 'f' ] || [ "${AFTER}" = 'fcd' ]; then fcd 1; fi; }
  local ESC=$(printf '\033')
  local SAVE_FILE=/tmp/mcd-pwd
  local MCD_SAVED_DIR=~
  if [ -f "${SAVE_FILE}" ]; then MCD_SAVED_DIR=$(cat /tmp/mcd-pwd); fi
  if [ "${1}" = '-' ]; then __cd $MCD_PREV_DIR; return 0; fi
  if [ "${1}" = '--' ]; then __cd $MCD_SAVED_DIR; return 0; fi
  if [ "${1}" = 'save' ]; then pwd > $SAVE_FILE; return 0; fi
  # you need to have an mc menu file
  local FN=~/.config/mc/hotlist
  if [ ! -f "${FN}" ]; then echo -e "${RED}mc hotlist file missing${NOCOLOR}"; return 1; fi
  # help: list the mc directory hotlist
  if [ -z "${1}" ]; then
    grep ENTRY ${FN} | sed s'/\s*ENTRY "//' | sed "s/\" URL \"/ ${ESC}[1;30m=> /" | sed "s/\"$/${ESC}[0m/"
    echo -e "${DARKGRAY}saved: ${MCD_SAVED_DIR}\nprev: ${MCD_PREV_DIR}${NOCOLOR}" | sed "s/\/home\/$(whoami)/~/g"
    return 0
  fi
  # first try to grep it with `"X "` in the mc hotlist (useful for prefixed lists), then go for a looser grep
  local TARGET=$(grep ENTRY ${FN} | grep "\"${1} " | head -1 | sed 's/.*URL "//' | sed 's/"$//')
  if [ $(echo $TARGET | wc -c) -gt 1 ]; then MCD_PREV_DIR=$(pwd); __cd $TARGET; return 0; fi
  # since "X nnn" was not found (for example `2` with `1 foobar`), let's try "N xxx" (in the `foobar`)
  TARGET=$(grep ENTRY ${FN} | sed 's/\s*ENTRY "[0-9A-Z]*\s//' | grep "^${1}" | head -1 |sed 's/.*URL "//' | sed 's/"$//')
  if [ $(echo $TARGET | wc -c) -gt 1 ]; then MCD_PREV_DIR=$(pwd); __cd $TARGET; return 0; fi
  __cd $1
}
function _mcd() {
  local cur=${COMP_WORDS[COMP_CWORD]}
  local FN=~/.config/mc/hotlist
  if [ ! -f "${FN}" ]; then return 1; fi
  local WORDS=$(grep ENTRY ${FN} | sed 's/\s*ENTRY "[0-9A-Z]*\s//' | sed 's/[" ].*//' | tr '\n' ' ')
  COMPREPLY=($(compgen -W "save ${WORDS}" -- ${cur}))
  return 0
}
complete -F _mcd mcd
# fzf + cd = fcd DEPTH (always quote, in case we have spaces in the name)
function fcd() {
  cd "$(find . -maxdepth ${1:-1} -path "*/node_modules" -prune -o -type d -print | fzf | xargs echo)"
}
# fzf + history + pbcopy = fhistory (and let's leave ctrl+r as is)
function fhistory() {
  local VAL=$(history | head -n -1 | tac | cut -c 8- | fzf)
  if [ ! -z "${VAL}" ]; then printf "${VAL}" | xclip -i -sel p -f | xclip -i -sel c; fi
}

# much short, very magic
alias g="git"
alias y="yarn"
if [ "$PLATFORM" = "mingw" ]; then alias y="node /c/Users/szabi/scoop/apps/yarn/current/Yarn/lib/cli.js"; fi
alias d="docker"
if [ "$PLATFORM" = "mingw" ]; then alias d='winpty docker'; fi
function p() {
  # (le) list errored, (lg) list grep, (ra) reset all, (da) delete all, (?/f) fuzzy operation, (n) number
  if [ "${1}" = 'le' ]; then pm2 l | grep -v '│ 0    │'; return 0; fi
  if [ "${1}" = 'lg' ]; then pm2 l | grep --color=never -Ei "${2}| id  |────────────" | grep -iz ${2}; return 0; fi
  if [ "${1}" = 'ra' ]; then pm2 reset all; return 0; fi
  if [ "${1}" = 'da' ]; then pm2 delete all; return 0; fi
  if [ "${1}" = 'n' ]; then
    local LINES="$(pm2 list | grep "${2}" | cut -c -78 | sed 's/│//g' | sed 's/default.*//g' | awk '{$1=$1};1' | sed 's/\s/ = /')"
    if [ "$(wc -l <<< $LINES)" -gt 1 ]; then echo "${LINES}"; fi
    pm2 list | grep "${2}" | cut -c -11 | sed 's/[^0-9]*//g' | xargs | sed -e 's/ /,/g'
    return 0
  fi
  local FUZZ=0
  if [ -z "${2}" ]; then
    if [ "${1}" = 'start' ] || [ "${1}" = 'stop' ] || [ "${1}" = 'delete' ] || [ "${1}" = 'restart' ]; then FUZZ=1; fi;
  fi
  if [ "${2}" = '?' ] || [ "${2}" = 'f' ] || [ "${FUZZ}" -eq 1 ]; then
    local IDS=$(pm2 list | grep -v WARN | fzf --exact --reverse --multi | sed 's/ //g' | sed 's/│/|/g' | cut -d '|' -f2 | xargs echo)
    if [ -z "${IDS}" ]; then return 0; fi
    echo -e "${CYAN}targets:${NOCOLOR} ${IDS} ${CYAN}operation:${NOCOLOR} ${1}"
    pm2 ${1} ${IDS}
    return 0
  fi
  pm2 $@
}

# npm, nvm and yarn
alias nuke="rm -rf ./node_modules && npm cache clear --force && npm install --no-shrinkwrap --update-binary"
alias npmr='npm run'
alias npmrd='npm run dev'
alias npmt='npm test'
alias npmrt='npm test'
alias npmtw='npm run test:watch'
alias npmrtw='npm run test:watch'
alias npmrl='npm run lint'
alias npmi='npm install && cp package.json .package.json && git checkout package-lock.json'
alias yadd='y add -D'
alias yins='y install'
alias yrem='y remove'
alias ys='y start'
alias yc='y clean'
alias yex='y start:exposed'
alias nP='nvm-project'

# change to node version specified by project
function nvm-project() {
  local NVER
  if [ -f ".nvmrc" ]; then
    NVER=$(cat .nvmrc)
    echo -e "${GREEN}nvmrc found, using v${NVER}${NOCOLOR}"
    nvm install $NVER
  else
    # try to use the Dockerfile (for major node version), if we can't, then just use the fall back
    if [ -f "Dockerfile" ]; then
      NVER=$(cat Dockerfile | grep -o "FROM node:[0-9]\+" | sed "s/FROM node://" | head -n1)
      echo -e "${ORANGE}nvmrc NOT found, falling back to Dockerfile, using node v${NVER}${NOCOLOR}"
      nvm install $NVER
    else
      echo -e "${RED}nvmrc/Dockerfile NOT found, sorry${NOCOLOR}"
    fi
  fi
}

# print the current nvm node version in the prompt
function current_node() {
  # NVER=$(readlink ~/.nvm/current | grep -o "node\/v.*" | sed "s/node\/v//")
  if [[ $(command -v node | wc -l) -eq 1 ]]; then
    local NVER=$(node -v)
    echo -e " ${CYAN}N:${NVER}${NOCOLOR}"
  fi
}

# editors and copy-paste (pri and sec)
alias nano='nano -x -w -z -H'
alias na='nano'
alias geany='geany'
if [ "$PLATFORM" = "macos" ]; then alias geany='open -a geany'; fi
if [ "$PLATFORM" = "mingw" ]; then alias geany='/c/Program\ Files\ \(x86\)/Geany/bin/geany.exe'; fi
alias vscode='code'
if [ "$PLATFORM" = "linux" ]; then
  alias pbcopy='xclip -i -sel p -f | xclip -i -sel c'
  alias pbpaste='xclip -selection clipboard -o'
fi
function copy-cat() { cat $@ | pbcopy; }
function copy-path() { readlink -f ${@:-.}; readlink -f ${@:-.} | head -c -1 | pbcopy; }
alias copy-fn='copy-path'

# edit popular files
alias ed-bp="${EDITOR} ~/.bash_profile"
alias ed-brc="${EDITOR} ~/.bashrc"
alias ed-ba="${EDITOR} ~/.bash_aliases"
alias ed-bs="${EDITOR} ~/.bash_secret"
alias ed-gc="${EDITOR} ~/.gitconfig"
alias ed-gi="${EDITOR} ~/.gitignore"
alias ed-mchot="${EDITOR} ~/.config/mc/hotlist"

# git prompt
function markup_git_branch() {
  if [[ -n $@ ]]; then
    if [[ -z $(git status --porcelain 2> /dev/null) ]]; then
      echo -e " ${GREEN}($@)${NOCOLOR}"
    else
      echo -e " ${RED}($@)${NOCOLOR}"
    fi
  fi
}
function parse_git_branch() {
  git branch --color=never 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \1/' | sed -e 's/feature/F/'
}

# detect mc subshell in prompt
function is_mc() {
  if [ -n "${MC_SID}" ]; then
    echo -e " ${ORANGE}MC▾${NOCOLOR}"
  fi
}

# setting titles (terminal / tmux / msys), controlling tmux
function title() { echo -ne "\033]0;${1}\007"; }
alias t="title"
alias tt="tmux rename-window"
function titleprefix() { TITLEPREFIX="$1"; }
alias tp="titleprefix"
function tmux-split-run() { tmux split-window -dh -t $TMUX_PANE "bash --rcfile <(echo '. ~/.bashrc;$*')"; }
alias tsr="tmux-split-run"
function tmux-split-run1() {
  if [ "$(tmux list-panes | wc -l | cut -d' ' -f1)" -gt 1 ]; then tmux kill-pane -t 2; fi
  tsr "$@"
}
alias tsr1="tmux-split-run1"

# misc
function jpg2mp4() { ffmpeg -loop 1 -i "$1" -c:v libx264 -t 15 -pix_fmt yuv420p "$1.mp4"; }
alias ytdl="youtube-dl"
alias ytdlmp3="youtube-dl -x --audio-format mp3"

# my file and mpd server, an ancient netbook
# for mingw use git sdk shell and `pacman -S expect`
function vacak_mpd() {
  NCMPCPP=1 expect -c '
    spawn ssh -o SendEnv=NCMPCPP szabi@$::env(VACAK_IP) -p1922
    log_user 0
    expect "assword:"; send "$::env(VACAK_PASSWORD)\r"
    interact
  '
}
function vacak_shell() {
  expect -c '
    spawn ssh szabi@$::env(VACAK_IP) -p1922
    log_user 0
    expect "assword:"; send "$::env(VACAK_PASSWORD)\r"
    interact
  '
}

# TESTBED / PJOT ZONE
# ===================

# only s2ram works reliably
alias s2ram="sudo s2ram && slock"
alias s2r="s2ram"
# name this the tmux pane as services, launch mongo left, rabbit right
alias rabbimongo="tt services; mongo40 & tsr1 rabbit"
# rename tmux pane to param or current dirname, append pm2 id if possible
function ttp() {
  local NAME="$(basename $(pwd))"
  if [ ! -z "${1}" ]; then NAME="${1}"; fi
  local NUM="$(p n $NAME)"
  if [ "$(wc -c <<< $NUM)" -gt 1 ] && [ "$(wc -l <<< $NUM)" -eq 1 ]; then
    tt "${NAME}.${NUM}"
  else
    tt "${NAME}"
  fi
}
