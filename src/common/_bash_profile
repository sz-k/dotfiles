# bash_profile is for login shells, while bashrc is for non-login shells, but this
# script can be used for either (macs will execute bash_profile on every terminal open anyway,
# and path items and aliases will be reset/normalized by the script)

# If not running interactively, don't do anything
case $- in
  *i*) ;;
    *) return;;
esac

PLATFORM=linux
if [[ `uname` = *"MINGW"* ]]; then
  PLATFORM=mingw
elif [[ `uname` = *"Darwin"* ]]; then
  PLATFORM=macos
else
  PLATFORM=linux
fi

# don't put duplicate lines or lines starting with space in the history.
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# colored GCC warnings and errors
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# alias definitions
unalias -a
if [ -f ~/.bash_aliases ]; then
  . ~/.bash_aliases
fi

# secret env vars
if [ -f ~/.bash_secret ]; then
  . ~/.bash_secret
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# I usually forget to copy (or download from git's repo) the git-completion.bash
if [ -f /usr/share/bash-completion/completions/git ]; then
  . /usr/share/bash-completion/completions/git
fi

# git autocomplete using brew on mac (brew install bash-completion)
if [ "$PLATFORM" = "macos" ]; then
  if [ -f `brew --prefix`/etc/bash_completion.d/git-completion.bash ]; then
    . `brew --prefix`/etc/bash_completion.d/git-completion.bash
  fi
fi

export TERM=xterm-256color

# mac colors
export CLICOLOR=1
export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx

# terminal colors (usage: `echo -e "foo ${RED}bar${NOCOLOR}"`)
# (no export, I'll use it in the shell only)
NOCOLOR='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
ORANGE='\033[0;33m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
LIGHTGRAY='\033[0;37m'
DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'

# some prompts (note the backslash before the $ sign)
#PS1='\[\e[0;32m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\] \[\e[0;37m\]'
#PS1="\[\e[0;32m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\]\[\e[0;33m\]$(parse_git_branch)$(is_git_clean)\[\e[1;32m\]\n\$:\\>\[\e[m\]\[\e[0;37m\]"
PS1="\[\e[0;32m\]\u\[\e[m\] \$(current_node)\[\e[1;34m\]\w\[\e[m\]\[\e[0;33m\]\$(markup_git_branch \$(parse_git_branch))\[\e[1;32m\]\n\$ \[\e[m\]\[\e[0;37m\]"

PATH=$PATH:~/bin:~/bin/rabbitmq/sbin:~/Nextcloud/Work/bin:~/Projects/planorama/DevScripts/services
if [ "$PLATFORM" = "mingw" ]; then PATH=$PATH:/c/git-sdk-64/usr/bin/; fi
EDITOR=nano
GUI_EDITOR=geany
export LANG=en_EN.UTF-8
export LC_CTYPE=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LESSCHARSET=UTF-8

# docker drives me nuts
if [ "$PLATFORM" = "mingw" ]; then export COMPOSE_CONVERT_WINDOWS_PATHS=1; fi

# make it work with the g alias (pretty much the same as `__git_complete g __git_main`)
if [[ $(declare -f _git) ]]; then
  complete -F _git g
fi

# python 2 for node-gyp fix
#export PYTHON=/usr/bin/python2.7

# I usually install npm with scoop on windows, so I'm not going to mess with globals' location
# on linux the following check is for sindre's non-root npm global guide
# (https://github.com/sindresorhus/guides/blob/master/npm-global-without-sudo.md)
if [ -d "${HOME}/.npm-packages" ]; then
  NPM_PACKAGES="${HOME}/.npm-packages"
  export PATH="$NPM_PACKAGES/bin:$PATH"
  unset MANPATH # delete if you already modified MANPATH elsewhere in your config
  export MANPATH="$NPM_PACKAGES/share/man:$(manpath)"
fi

# for nvm: this is a much faster, but still kinda safe nvm init
# (nvm install 10, nvm install 12, nvm use 12, nvm alias default 10, etc. works)
# (based on https://www.growingwiththeweb.com/2018/01/slow-nvm-init.html#comment-4188210568)
if [ -d "${HOME}/.nvm" ]; then
  export NVM_SYMLINK_CURRENT=true
  export NVM_DIR=~/.nvm
  source $NVM_DIR/nvm.sh --no-use
  NODE_VERSION=$(ls -1 ~/.nvm/versions/node/ | grep --color=never "v$(cat $NVM_DIR/alias/default)" | tail -n1)
  FILE=/etc/resolv.conf
  if [ -f "$NVM_DIR/versions/node/$NODE_VERSION/bin/node" ]; then
    export PATH="$NVM_DIR/versions/node/$NODE_VERSION/bin:$PATH"
    ln -sf $(which node) $NVM_DIR/current
  else
    # FIXME this may happen with `nvm alias default node`
    echo "warning: nvm fallback!"
    # default nvm (kinda slow, because of the sanity checks)
    export NVM_DIR="$HOME/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
  fi
fi

# allow passing NVMUSE env var to immediately switch to a version
if [ ! -z "${NVMUSE}" ]; then
  unset npm_config_prefix
  nvm use ${NVMUSE}
fi

# remove path dups (finally)
PATH="$(perl -e 'print join(":", grep { not $seen{$_}++ } split(/:/, $ENV{PATH}))')"
